#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
/* note - for windows this is different */
#include <sys/mman.h> 

#include "dynasm/dasm_proto.h"
#include "dynasm/dasm_x86.h"

// DynASM directives.
|.arch x64
|.actionlist actions
/* call a function (64 bit)
 * and yes, i did steal this from jitdemo :-) */
|.macro callp, addr
|  mov64  rdx, (uintptr_t)addr
|  call   rdx
|.endmacro


void foo(dasm_State **Dst) {
    | push rbp
    | mov rbp, rsp
    | push rdi
    | push rsi
}

void bar(dasm_State **Dst) {
    | mov eax, dword [rbp-8]
    | imul eax, dword [rbp-16]
}

void baz(dasm_State **Dst) {
    | mov rsp, rbp
    | pop rbp
    | ret
}

void dump(char * file, char * mem, size_t s) {
     FILE * f = fopen(file, "w");
     fwrite(mem, sizeof(char), s, f);
     fclose(f);
}

int main(int argc, char **argv) {
    dasm_State * state;
    size_t codesize;
    char * memory;
    int (*fp)(int, int);
    int i, result;
    /* initialize the assembler structure */
    dasm_init(&state, 1);
    dasm_setup(&state, actions);
    /* add some instructions */
    foo(&state);
    bar(&state);
    baz(&state);
    /* link the code and get its' final size */
    dasm_link(&state, &codesize);
    /* get r/w memory */
    memory = mmap(NULL, codesize, PROT_READ | PROT_WRITE,
                  MAP_ANON | MAP_PRIVATE, -1, 0);
    /* write the machine code */
    dasm_encode(&state, memory);
    dump("example.dump", memory, codesize);
    /* clear up the assembler */
    dasm_free(&state);
    /* make the memory executable */
    mprotect(memory, codesize, PROT_EXEC | PROT_READ);
    /* cast to function */
    fp = (int(*)(int, int)) memory;
    /* call the function */
    result = fp(6,7);
    printf("hello %d\n", result);
    /* destroy the memory */
    munmap(memory, codesize);
    /* and leave */
    exit(0);
}
